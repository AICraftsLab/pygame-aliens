# -*- coding: utf-8 -*-
"""torch_ppo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eAdSFuqxV9fkmjpQyS19J20BlCszMggz
"""

import sys
import os
import torch
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt
import numpy as np
import warnings
from torch.distributions.categorical import Categorical
import pygame as pg

from nn_visualizer import NeuralNetworkVisualizer
from aliens import AliensEnv

warnings.simplefilter("ignore")


def standardize(state):
    data = np.array(state)

    # Compute the mean and standard deviation
    mean = np.mean(data, axis=0)
    std_dev = np.std(data, axis=0)

    # Avoid division by zero by setting std_dev to 1 where it is 0
    std_dev = np.where(std_dev == 0, 1, std_dev)

    # Standardize the data
    standardized_data = (data - mean) / std_dev

    return standardized_data

def get_layers_weight(net):
    if True:
        layers_weight = []
        layer_id = 0
        for layer in net.children():
            if isinstance(layer, torch.nn.Linear):
                print(layer)
                weights = layer.weight.detach().numpy()
                layers_weight.append(weights)
                print(weights[:5])
                print()
                break
                
        return layers_weight

surface = pg.display.set_mode((840, 660))
env = AliensEnv(surface, render=True, fps=100)

state_dim = env.n_observations
action_dim = env.n_actions

class ActorPredNwk(nn.Module):
    def __init__(self,input_dim,out_dim,
                 checkpoint_file,
                 hidden_dim=128
                 ):
        super(ActorPredNwk, self).__init__()

        self.checkpoint_file = checkpoint_file
        self.actor_nwk = nn.Sequential(
            nn.Linear(input_dim,hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim,hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim,out_dim),
            nn.Softmax(dim=-1)
        )
        
        self.device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        self.to(self.device)

    def forward(self,state):
        x = torch.tensor([state], dtype=torch.float).to(self.device)
        out = self.actor_nwk(x)
        dist = Categorical(out)
        action = dist.sample()
        action = torch.squeeze(action).item()
        
        return action

    def load_checkpoint(self):
        self.load_state_dict(torch.load(self.checkpoint_file))

saves_folder = ''
load_checkpoint_num = -1

#print('Usage: python', __name__, '-c 2025 [-s 0]')
if len(sys.argv) > 1:
    for i in range(1, len(sys.argv), 2):
        arg = sys.argv[i]
        arg_value = sys.argv[i+1]
        if arg == '-s':
            saves_folder = arg_value
        elif arg == '-c':
            load_checkpoint_num = arg_value
    
    if saves_folder == '0':
        saves_folder = ''
else:
    raise Exception('Invalid arguments: Pass checkpoint to load')
    
if load_checkpoint_num == -1:
    raise Exception('Invalid arguments: Pass checkpoint to load')
    
file = f'./saves{saves_folder}/actor_{load_checkpoint_num}'

policy_nwk = ActorPredNwk(input_dim=state_dim,out_dim=action_dim, checkpoint_file=file)
policy_nwk.load_checkpoint()
print('Checkpoint:', file)

#weights = get_layers_weight(policy_nwk.actor_nwk)
#print(weights)
#print('XXXXXXXXXXXXXXXXXX')
#weights_ = torch.load(policy_nwk.checkpoint_file)
#for layer, w in weights_.items():
#    print(layer)
#    print(w[:5])
#    print()
#    break

while True:
  done = False
  state, info = env.reset()
  rewards = 0
  while not done:
      state = standardize(state)
      action = policy_nwk(state)
      #action = torch.argmax(action).item()
      state, reward, done, info = env.step(action)
      rewards += reward
  print(info, 'Reward: ', round(rewards, 2))
